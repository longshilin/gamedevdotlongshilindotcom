---
layout: post 
title: "ECS概念"
date: 2021-08-23 
categories: DOTS 
tags: unity ecs dots 
excerpt: Entities官方文档译文（Entities 0.17.0-preview.42）
---
* content 
{:toc}

# ECS 概念

一个实体组件系统（ECS）架构将标识（实体）、数据（组件）和行为（系统）分离开。体系结构侧重于数据。系统读取组件数据流，然后将数据从输入状态转换为输出状态，然后对输出状态进行索引。

下图说明了这三个基本部分是如何协同工作的：
![](https://cdn.jsdelivr.net/gh/longshilin/images/20210830211246.png)

在这个图中，系统读取`Translation`和`Rotation`组件，将它们相乘，然后更新相应的 `LocalToWorld` 组件(L2W = t * r)。

事实上，实体A和B具有`Renderer`组件而实体C不包含的情况下不影响系统，因为系统不关心 `Renderer` 组件。

你可以设置一个系统，以便它需要一个渲染器组件，在这种情况下，系统忽略实体C的组件；或者，你可以设置一个系统，以排除具有 `Renderer` 组件的实体，然后忽略实体A和B的组件。

## 原型

组件类型的唯一组合称为 [EntityArchetype (实体原型)](#)
。例如，一个3D对象可能有一个组件用于它的世界坐标转换，一个用于它的线形运动，一个用于旋转，一个用于它的视觉表现。这些3D对象中的每个实例都对应一个实体，但由于它们共享相同的组件集，ECS将它们归类为单一原型：

![](https://cdn.jsdelivr.net/gh/longshilin/images/20210830214438.png)

在这个图中，实体A和实体B共享原型M，而实体C共享原型N。

若要顺序更改实体的原型，可以在运行时添加或删除组件。例如，如果从实体B中删除 `Renderer` 组件，那么它将移动到原型N。

## 内存块

实体的原型确定ECS在何处存储改实体组件。ECS以“块”的形式分配内存，每个块由一个 [ArchetypeChunk (原型块)](#)
对象表示。块总是包含单一原型的实体。当内存块满了时，ECS为使用相同原型创建的任何新实体分配新的内存块。如果你添加或删除组件，然后更改实体原型，ECS将该实体的组件移动到不同的块。

![](https://cdn.jsdelivr.net/gh/longshilin/images/20210830220232.png)

这种组织方案在原型和块之间提供了一对多的关系。这也意味着，要找到具有给定组件集的所有实体，只需要通过现有原型进行搜索，而不需要通过所有实体进行搜索，因为现有原型的数量通常很少，而所有实体的数量要大得多。

ECS不以特定的顺序存储块中的实体。当一个实体被创建或者更改为一个新的原型时，ECS将其放入第一个存储原型有空间的块中。但是，块仍然保持紧密包装；当一个实体从原型中移除时，ECS将块中最后一个实体的组件移动到组件数组中新腾出的槽中。

> ##### 注意
>
> 原型中共享组件的值还确定实体该存储在哪个块中。给定块中的所有实体对于任何共享组件都具有完全相同的值。如果更改共享组件中任何字段的值，被修改的实体将移动到不同的块，就像更改该实体的原型一样。如果有必要，将分配一个新块。

当将共享组件一起处理更有效时，使用共享组件对原型中的实体进行分组。例如，Hybrid Renderer 定义了它的 RenderMesh 组件来实现这一点。

## 实体查询

若要确定系统应处理那些实体，请使用 [EntityQuery](#)。实体查询在现有原型中搜索那些具有与你的需求匹配的组件的原型。你可以通过查询指定以下组件需求：

- All —— 原型必须包含All分类。
- Any —— 原型必须至少包含Any分类。
- None —— 原型不得包含None分类。

实体查询提供了包含查询所需组件类型的块的列表。然后可以使用 [IJobEntityBatch](#)直接迭代这些块中的组件。

## Jobs

要利用多线程的优势，可以使用 [C# Job System](#)。ECS提供了 [SystemBase]() 类以及 `Entities.ForEach` 和 [IJobEntityBatch](#) `Schedule()` 和 `ScheduleParallel()` 方法，用于在主线程之外转换数据。`Entities.Foreach` 使用起来最简单，通常需要实现的代码行数较少。你可以使用 `IJobChunk` 处理那些 `Entities.ForEach` 无法处理的更复杂情况。

ECS按照系统安排的顺序在主线程上调度作业。在调度作业时，ECS跟踪读取哪些作业和写入哪些组件。读取组件的作业依赖于先前写入同一组件的任何调度作业，反之亦然。作业调度程序使用作业依赖关系来确定哪些作业可以并行运行，哪些作业必须按顺序运行。

## 系统组织
ECS通过 [World](#) 组织系统然后通过 [Group](#) 分组。默认情况下，ECS创建一个带有一组预定义组的默认World。它查找所有可用的系统，实例化它们，并将它们添加到默认World的预定义 [Simulation Group](#) 中。

你可以指定同一组中系统的更新顺序。一个组是一种系统，因此你可以将一个组添加到另一个组，并像其他系统一样指定其顺序。组中的所有系统在一个系统或组之前进行更新。如果不指定顺序，ECS将以不依赖创建顺序的确定性方式将系统插入到更新顺序中。换句话说，即使你没有显式得指定一个顺序，相同的系统集总是以相同的顺序在它们的组中进行更新。

有关系统创建、更新顺序和可用于组织系统的属性的详细信息，请参阅 [System Update Order](#)

## ECS创作（ECS Authoring）
当你在Unity编辑器中创建你的游戏或应用程序时，你可以使用GameObjects和MonoBehaviors来创建一个转换系统来讲这些UnityEngine对象和组件映射到实体。有关更多信息，请参见 [Creating GamePlay](#)。

<!--
https://interpreter.caiyunai.com/html/612cd66543bc1736b37e70f2
-->

















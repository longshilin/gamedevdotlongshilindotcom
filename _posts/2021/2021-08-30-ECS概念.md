---
layout: post title: "ECS概念"
date: 2021-08-23 categories: DOTS tags: unity ecs dots excerpt: Entities官方文档译文（Entities 0.17.0-preview.42）
---

* content {:toc}

# ECS 概念

一个实体组件系统（ECS）架构将标识（实体）、数据（组件）和行为（系统）分离开。体系结构侧重于数据。系统读取组件数据流，然后将数据从输入状态转换为输出状态，然后对输出状态进行索引。

下图说明了这三个基本部分是如何协同工作的：
![](https://cdn.jsdelivr.net/gh/longshilin/images/20210830211246.png)

在这个图中，系统读取`Translation`和`Rotation`组件，将它们相乘，然后更新相应的 `LocalToWorld` 组件(L2W = t * r)。

事实上，实体A和B具有`Renderer`组件而实体C不包含的情况下不影响系统，因为系统不关心 `Renderer` 组件。

你可以设置一个系统，以便它需要一个渲染器组件，在这种情况下，系统忽略实体C的组件；或者，你可以设置一个系统，以排除具有 `Renderer` 组件的实体，然后忽略实体A和B的组件。


## 原形

组件类型的唯一组合称为 [EntityArchetype (实体原型)](#)。例如，一个3D对象可能有一个组件用于它的世界坐标转换，一个用于它的线形运动，一个用于旋转，一个用于它的视觉表现。这些3D对象中的每个实例都对应一个实体，但由于它们共享相同的组件集，ECS将它们归类为单一原型：

![](https://cdn.jsdelivr.net/gh/longshilin/images/20210830214438.png)

在这个图中，实体A和实体B共享原型M，而实体C共享原型N。

若要顺序更改实体的原型，可以在运行时添加或删除组件。例如，如果从实体B中删除 `Renderer` 组件，那么它将移动到原型N。


## 内存块

实体的原型确定ECS在何处存储改实体组件。ECS以“块”的形式分配内存，每个块由一个 [ArchetypeChunk (原型块)](#)对象表示。块总是包含单一原型的实体。当内存块满了时，ECS为使用相同原型创建的任何新实体分配新的内存块。如果你添加或删除组件，然后更改实体原型，ECS将该实体的组件移动到不同的块。

![](https://cdn.jsdelivr.net/gh/longshilin/images/20210830220232.png)

这种组织方案在原型和块之间提供了一对多的关系。这也意味着，要找到具有给定组件集的所有实体，只需要通过现有原型进行搜索，而不需要通过所有实体进行搜索，因为现有原型的数量通常很少，而所有实体的数量要大得多。

ECS不以特定的顺序存储块中的实体。当一个实体被创建或者更改为一个新的原型时，ECS将其放入第一个存储原型有空间的块中。但是，块仍然保持紧密包装；当一个实体从原型中移除时，ECS将块中最后一个实体的组件移动到组件数组中新腾出的槽中。

>##### 注意
>
> 原型中共享组件的值还确定实体该存储在哪个块中。给定块中的所有实体对于任何共享组件都具有完全相同的值。如果更改共享组件中任何字段的值，被修改的实体将移动到不同的块，就像更改该实体的原型一样。如果有必要，将分配一个新块。

当将共享组件一起处理更有效时，使用共享组件对原型中的实体进行分组。例如，Hybrid Renderer 定义了它的 RenderMesh 组件来实现这一点。

## 实体查询
若要确定系统应处理那些实体，请使用 [EntityQuery](#)。实体查询在现有原型中搜索那些具有与你的需求匹配的组件的原型。你可以通过查询指定以下组件需求：

- All —— 原型必须包含All分类。
- Any —— 原型必须至少包含Any分类。
- None —— 原型不得包含None分类。

实体查询提供了包含查询所需组件类型的块的列表。然后可以使用 [IJobEntityBatch](#)直接迭代这些块中的组件。

## Jobs


<!--
https://interpreter.caiyunai.com/html/612cd66543bc1736b37e70f2
-->
















